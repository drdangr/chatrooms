# План разработки Multi-User LLM Chat MVP

## Правила заполнения плана

### Общие правила работы с планом разработки:

- **На каждом новом этапе** пишем задачу этапа и его DOD (Definition of Done) + тесткейс

- **Приступая к каждому этапу** текущие задачи помечаются в чек-боксе `[*]`, что означает, что задача в работе

- **После выполнения этапа** нужно:
  1. Пройти тесткейс самостоятельно
  2. Получить от пользователя подтверждение, что этап закрыт
  3. Только после этого можно пометить задачу в чек-боксе `[X]`, что означает, что она выполнена

- **При появлении дополнительных задач** нужно вписать их в план

- **При появлении проблем** нужно сделать в плане пометку: "**ПРОБЛЕМА:** [описание проблемы]"

- **Не удаляй из плана задачи**, если они были выполнены, а отмечай их выполненными

- **При изменении задач** попроси у пользователя подтверждения и согласуй с ним изменения, только после получения его одобрения - можно вносить изменения в план

---

## Этап 1: Инициализация проекта и настройка бэкенда ✅ ЗАВЕРШЕН

**Задача этапа:** Настроить базовую инфраструктуру проекта, создать проект в Supabase, настроить схему базы данных, настроить аутентификацию.

**DOD (Definition of Done):**
- ✅ Создан проект в Supabase
- ✅ Настроена схема БД с таблицами: users, rooms, messages, files
- ✅ Настроена аутентификация через Supabase Auth (Google OAuth)
- ✅ Создан тестовый пользователь (автоматически через триггер)
- ✅ Проверена работа подключения к БД (все тесты пройдены)

**Тесткейс:**
1. ✅ Создать проект в Supabase
2. ✅ Настроить таблицы в БД через SQL Editor или миграции
3. ✅ Проверить структуру таблиц
4. ✅ Настроить аутентификацию
5. ✅ Создать тестового пользователя (drdangr@gmail.com)
6. ✅ Проверить подключение к БД через клиент (все тесты успешны)

**Задачи:**

- [X] 1.1. Инициализировать React проект с TypeScript
  - [X] Настроить проект (Vite/Create React App)
  - [X] Установить зависимости (React, TypeScript, TailwindCSS)
  - [X] Настроить структуру папок проекта
  
- [X] 1.2. Создать и настроить проект Supabase
  - [X] Зарегистрироваться/войти в Supabase
  - [X] Создать новый проект
  - [X] Сохранить credentials (URL, anon key, service key)
  
- [X] 1.3. Создать схему базы данных
  - [X] Создать таблицу `users` (id, email, name, avatar_url, created_at)
  - [X] Создать таблицу `rooms` (id, title, system_prompt, model, created_by, created_at)
  - [X] Создать таблицу `messages` (id, room_id, sender_id, sender_name, text, timestamp, created_at)
  - [X] Создать таблицу `files` (id, room_id, uploaded_by, filename, file_url, file_type, size, created_at)
  - [X] Настроить связи между таблицами (foreign keys)
  - [X] Настроить индексы для оптимизации запросов
  - [X] Создать SQL миграцию в файле `supabase/migrations/001_initial_schema.sql`
  - [X] Применить миграцию в Supabase Dashboard
  
- [X] 1.4. Настроить аутентификацию
  - [X] Включить Supabase Auth (включен по умолчанию)
  - [X] Настроить провайдер Google OAuth
    - [X] Создать OAuth клиент в Google Cloud Console
    - [X] Получить Client ID и Client Secret
    - [X] Ввести credentials в Supabase Dashboard
    - [X] Протестировать вход через Google
  - [ ] Настроить провайдер Apple OAuth (опционально)
  - [X] Настроить политики безопасности (RLS - Row Level Security) - выполнено в миграции
  
- [X] 1.5. Установить и настроить Supabase клиент
  - [X] Установить @supabase/supabase-js
  - [X] Создать файл конфигурации с credentials
  - [X] Создать утилиту для инициализации клиента
  - [X] Создать компонент Auth для аутентификации
  - [X] Создать компонент AuthCallback для обработки OAuth callback
  - [X] Настроить роутинг (React Router)
  - [X] Создать компонент DBConnectionTest для тестирования БД
  - [X] Протестировать подключение к БД ✅ (все тесты пройдены успешно)

---

## Этап 2: Базовый UI - интерфейс комнат и сообщений ✅ ЗАВЕРШЕН

**Задача этапа:** Создать базовый пользовательский интерфейс для списка комнат и чата с сообщениями, реализовать real-time синхронизацию сообщений.

**DOD (Definition of Done):**
- ✅ Реализован компонент списка комнат (ChatList)
- ✅ Реализован компонент чата (ChatRoom) с отображением сообщений
- ✅ Реализована отправка сообщений
- ✅ Настроена real-time синхронизация через Supabase Realtime
- ✅ Пользователь может создавать комнаты, присоединяться к существующим
- ✅ Сообщения сохраняются в БД и отображаются в реальном времени

**Тесткейс:**
1. ✅ Авторизоваться в приложении
2. ✅ Создать новую комнату с названием
3. ✅ Отправить несколько сообщений
4. ✅ Открыть приложение в другом браузере/вкладке
5. ✅ Проверить, что сообщения синхронизируются в реальном времени
6. ✅ Проверить отображение истории сообщений при повторном входе

**Задачи:**

- [X] 2.1. Создать базовую структуру компонентов
  - [X] Создать компонент Layout
  - [X] Создать компонент ChatList (список комнат)
  - [X] Создать компонент ChatRoom (интерфейс чата)
  - [X] Настроить роутинг (React Router)
  - [X] Создать ProtectedRoute для защиты маршрутов
  
- [X] 2.2. Реализовать компонент ChatList
  - [X] Отображение списка доступных комнат
  - [X] Кнопка создания новой комнаты
  - [X] Поиск комнат по названию
  - [X] Навигация к выбранной комнате
  
- [X] 2.3. Реализовать компонент ChatRoom
  - [X] Отображение списка сообщений
  - [X] Форма ввода и отправки сообщений
  - [X] Отображение имени отправителя и времени
  - [X] Скролл к новым сообщениям
  
- [X] 2.4. Реализовать CRUD операции для комнат
  - [X] Создание комнаты (INSERT в таблицу rooms)
  - [X] Получение списка комнат (SELECT)
  - [ ] Удаление комнаты (DELETE) - отложено на будущее
  - [ ] Обновление названия комнаты (UPDATE) - отложено на будущее
  
- [X] 2.5. Реализовать CRUD операции для сообщений
  - [X] Отправка сообщения (INSERT в таблицу messages)
  - [X] Получение истории сообщений комнаты (SELECT с фильтром по room_id)
  - [ ] Пагинация сообщений (загрузка по частям) - опционально на данном этапе
  
- [X] 2.6. Настроить Supabase Realtime для синхронизации
  - [X] Подписаться на изменения в таблице messages
  - [X] Подписаться на изменения в таблице rooms
  - [X] Обработка событий insert
  - [X] Обновление UI при получении новых событий
  - [X] Включить Realtime для таблиц в Supabase (через SQL Editor) ✅
  - [X] Протестировать real-time синхронизацию ✅
  
- [X] 2.7. Стилизация интерфейса
  - [X] Применить TailwindCSS для базовых стилей
  - [X] Создать компоненты для карточек комнат
  - [X] Создать компоненты для сообщений (пузыри чата)
  - [X] Адаптивная верстка для мобильных устройств (базовая)

---

## Этап 3: Интеграция LLM ✅ ЗАВЕРШЕН

**Задача этапа:** Интегрировать API LLM (OpenAI/Mistral) для получения ответов ассистента в чате на основе системного промпта.

**DOD (Definition of Done):**
- ✅ Настроено подключение к API OpenAI
- ✅ Реализована функция отправки запросов к LLM
- ✅ LLM отвечает в чате на основе системного промпта комнаты
- ✅ Ответы LLM сохраняются в БД как сообщения от "LLM"
- ✅ Обработаны ошибки API
- ✅ Протестирована работа LLM ✅

**Тесткейс:**
1. ✅ Создать комнату с системным промптом
2. ✅ Отправить сообщение в чат
3. ✅ Проверить, что LLM получает запрос и формирует ответ
4. ✅ Проверить сохранение ответа LLM в БД
5. ✅ Проверить отображение ответа в интерфейсе
6. ✅ Проверить обработку ошибок при недоступности API

**Задачи:**

- [X] 3.1. Настроить API ключи и конфигурацию
  - [X] Получить API ключ OpenAI
  - [X] Создать переменные окружения для хранения ключей
  - [X] Настроить .env файл и добавить в .gitignore
  
- [X] 3.2. Создать сервис для работы с LLM API
  - [X] Создать функцию для отправки запросов к API
  - [X] Реализовать форматирование системного промпта
  - [X] Реализовать форматирование истории сообщений
  - [X] Реализовать обработку ответа от API
  
- [X] 3.3. Интегрировать LLM в поток сообщений
  - [X] Настроить триггер вызова LLM при новом сообщении от пользователя
  - [X] Передавать системный промпт комнаты в запрос
  - [X] Передавать историю сообщений в контекст
  - [X] Сохранять ответ LLM в БД как сообщение от "LLM"
  
- [X] 3.4. Реализовать обработку ошибок и состояний загрузки
  - [X] Обработка ошибок API (таймауты, rate limits, невалидные ключи)
  - [X] Сообщения об ошибках для пользователя (системные сообщения)
  - [ ] Индикатор загрузки ответа LLM - отложено
  - [ ] Retry механизм при временных ошибках - отложено
  
- [X] 3.5. Оптимизация запросов к LLM
  - [X] Ограничение длины истории сообщений в контексте (последние 10 сообщений)
  - [ ] Кэширование промптов - отложено
  - [X] Защита от множественных запросов (sending флаг)

---

## Этап 4: Настройки - промпт и выбор модели

**Задача этапа:** Реализовать интерфейс для редактирования системного промпта комнаты и выбора модели LLM.

**DOD (Definition of Done):**
- Создан компонент PromptSettings для редактирования промпта
- Реализован выбор модели LLM (gpt-4o-mini, gpt-4, mistral и т.д.)
- Изменения промпта и модели сохраняются в БД
- Изменения применяются к последующим ответам LLM
- Интерфейс интуитивно понятен и доступен

**Тесткейс:**
1. Открыть настройки комнаты
2. Изменить системный промпт на новый текст
3. Выбрать другую модель LLM
4. Сохранить изменения
5. Отправить новое сообщение
6. Проверить, что LLM использует новый промпт и модель

**Задачи:**

- [X] 4.1. Создать компонент PromptSettings
  - [X] Текстовое поле для редактирования системного промпта
  - [X] Выпадающий список для выбора модели
  - [X] Кнопки сохранения и отмены
  - [X] Валидация введенных данных (базовая)
  
- [X] 4.2. Реализовать выбор модели LLM
  - [X] Создать список доступных моделей (gpt-4o-mini, gpt-4o, gpt-4, gpt-3.5-turbo)
  - [X] Отображение текущей выбранной модели
  - [X] Обновление модели в БД при изменении
  
- [X] 4.3. Реализовать редактирование системного промпта
  - [X] Загрузка текущего промпта из БД
  - [X] Редактирование в текстовом поле (поддержка многострочного ввода)
  - [X] Сохранение промпта в БД
  - [X] Применение промпта к последующим запросам LLM
  
- [X] 4.4. Интегрировать настройки в интерфейс
  - [X] Добавить кнопку настроек в ChatRoom
  - [X] Модальное окно для настроек
  - [X] Обновление интерфейса при изменении настроек (перезагрузка страницы)
  
- [X] 4.5. Добавить валидацию и подсказки
  - [X] Подсказки по использованию промптов
  - [X] Примеры хороших промптов (кнопки для быстрого выбора)
  - [ ] Проверка длины промпта - отложено (можно добавить позже)

---

## Этап 5: Семантический поиск по истории чата ✅ ЗАВЕРШЕН

**Задача этапа:** Реализовать семантический поиск по истории сообщений с использованием векторных эмбеддингов для поиска по смыслу, а не по точному совпадению слов.

**DOD (Definition of Done):**
- ✅ Настроена поддержка векторных эмбеддингов в БД (pgvector extension)
- ✅ Реализована генерация эмбеддингов для всех сообщений (пользователь, LLM, системные)
- ✅ Реализована SQL функция для семантического поиска
- ✅ Реализован UI для семантического поиска
- ✅ Реализована утилита для пересоздания эмбеддингов
- ✅ Настроена поддержка русского языка (text-embedding-3-large с уменьшенной размерностью)
- ✅ Пользователь может искать сообщения по смыслу, переходить к найденным сообщениям

**Тесткейс:**
1. ✅ Открыть комнату с историей сообщений
2. ✅ Открыть панель семантического поиска
3. ✅ Ввести запрос на поиск по смыслу
4. ✅ Проверить отображение найденных сообщений с показателем сходства
5. ✅ Кликнуть на результат и проверить переход к сообщению
6. ✅ Протестировать поиск на русском языке
7. ✅ Пересоздать эмбеддинги для всех сообщений

**Задачи:**

- [X] 5.1. Настроить векторные эмбеддинги в БД
  - [X] Установить и настроить pgvector extension в Supabase
  - [X] Добавить колонку `embedding vector(1024)` в таблицу `messages`
  - [X] Создать индекс для быстрого поиска (HNSW)
  - [X] Создать SQL функцию `search_messages_semantic` для семантического поиска
  - [X] Настроить миграцию (010_add_message_embeddings.sql)
  
- [X] 5.2. Реализовать генерацию эмбеддингов
  - [X] Интегрировать OpenAI Embeddings API
  - [X] Реализовать функцию генерации эмбеддингов для сообщений
  - [X] Автоматическая генерация эмбеддингов при создании сообщений (пользователь, LLM, системные)
  - [X] Реализовать batch генерацию для пересоздания эмбеддингов
  - [X] Настроить модель и размерность для русского языка (text-embedding-3-large, 1024 dim)
  
- [X] 5.3. Реализовать семантический поиск
  - [X] Создать функцию поиска с использованием косинусного сходства
  - [X] Реализовать фильтрацию по комнате
  - [X] Реализовать сортировку по релевантности
  - [X] Обработка ошибок и edge cases
  
- [X] 5.4. Реализовать UI для поиска
  - [X] Добавить панель семантического поиска в ChatRoom
  - [X] Реализовать поле ввода для поискового запроса
  - [X] Реализовать отображение результатов с показателем сходства
  - [X] Реализовать переход к найденному сообщению при клике
  - [X] Добавить кнопку для пересоздания эмбеддингов (для админов)
  
- [X] 5.5. Настроить поддержку русского языка
  - [X] Исследовать модели эмбеддингов для русского языка
  - [X] Настроить text-embedding-3-large с уменьшенной размерностью (1024) для соответствия ограничениям pgvector
  - [X] Создать миграцию для переключения на large модель (012_switch_to_large_embeddings.sql)
  - [X] Добавить переменные окружения для настройки модели и размерности
  - [X] Создать документацию по настройке для русского языка (Docs/EMBEDDINGS_RUSSIAN.md)
  
- [X] 5.6. Утилиты для управления эмбеддингами
  - [X] Реализовать функцию пересоздания эмбеддингов для одной комнаты
  - [X] Реализовать функцию пересоздания эмбеддингов для всех комнат
  - [X] Добавить UI для пересоздания эмбеддингов
  - [X] Исправить RLS политики для обновления эмбеддингов LLM сообщений (011_fix_embedding_update_rls.sql)

---

## Этап 6: Загрузка и просмотр файлов

**Задача этапа:** Реализовать функциональность загрузки файлов в комнаты и их просмотр, используя Supabase Storage.

**DOD (Definition of Done):**
- Настроен Supabase Storage bucket для файлов
- Реализована загрузка файлов через интерфейс
- Файлы сохраняются в Storage и метаданные в БД
- Реализован просмотр списка файлов комнаты
- Реализован просмотр/скачивание файлов
- Файлы привязаны к комнатам и доступны участникам

**Тесткейс:**
1. Открыть комнату
2. Загрузить файл (текстовый, изображение, PDF)
3. Проверить сохранение файла в Storage
4. Проверить отображение файла в списке файлов комнаты
5. Открыть/скачать файл
6. Проверить доступность файла для других участников комнаты

**Задачи:**

- [ ] 6.1. Настроить Supabase Storage
  - [ ] Создать bucket для хранения файлов
  - [ ] Настроить политики доступа (RLS для Storage)
  - [ ] Ограничения на размер и типы файлов
  
- [ ] 6.2. Создать компонент FilePanel
  - [ ] Список загруженных файлов комнаты
  - [ ] Кнопка/зона для загрузки файлов
  - [ ] Отображение метаданных файлов (имя, размер, тип, дата)
  - [ ] Иконки по типам файлов
  
- [ ] 6.3. Реализовать загрузку файлов
  - [ ] Drag & drop или выбор файла через input
  - [ ] Валидация типа и размера файла
  - [ ] Загрузка файла в Supabase Storage
  - [ ] Сохранение метаданных в таблицу files
  - [ ] Индикатор прогресса загрузки
  
- [ ] 6.4. Реализовать просмотр файлов
  - [ ] Получение списка файлов комнаты из БД
  - [ ] Генерация URL для доступа к файлам
  - [ ] Просмотр изображений в интерфейсе
  - [ ] Скачивание файлов
  - [ ] Открытие файлов в новой вкладке
  
- [ ] 6.5. Интегрировать файлы в чат
  - [ ] Отображение файлов в сообщениях (если прикреплены)
  - [ ] Возможность прикрепить файл к сообщению
  - [ ] Превью файлов в сообщениях
  
- [ ] 6.6. Реализовать удаление файлов
  - [ ] Кнопка удаления для владельца файла
  - [ ] Удаление файла из Storage
  - [ ] Удаление записи из БД

---

## Этап 7: Деплой и финализация MVP

**Задача этапа:** Развернуть приложение на Vercel, настроить переменные окружения, провести финальное тестирование и подготовить MVP к использованию.

**Примечание:** Промежуточный деплой для тестирования выполнен после завершения Этапа 4 (настройки промпта и модели). Финальный деплой будет выполнен после завершения всех этапов.

**DOD (Definition of Done):**
- Приложение развернуто на Vercel
- Настроены все переменные окружения
- Протестированы все основные функции
- Приложение доступно по публичному URL
- Документация по деплою обновлена
- MVP готов к использованию

**Тесткейс:**
1. Развернуть приложение на Vercel
2. Настроить переменные окружения
3. Проверить работу аутентификации
4. Проверить работу всех функций (чат, LLM, настройки, поиск, файлы)
5. Протестировать на разных устройствах/браузерах
6. Проверить производительность и скорость загрузки

**Задачи:**

- [X] 7.1. Подготовка к деплою (промежуточный деплой для тестирования)
  - [X] Убедиться, что код готов к production
  - [ ] Проверить отсутствие console.log и debug кода (оставлено для отладки на данном этапе)
  - [X] Оптимизировать сборку (минификация, tree-shaking) - выполнено автоматически Vite
  - [X] Проверить работу в production режиме локально - сборка успешна
  - [X] Создать инструкцию по деплою (VERCEL_DEPLOY.md)
  
- [X] 7.2. Настройка Vercel (промежуточный деплой для тестирования)
  - [X] Создать проект в Vercel
  - [X] Подключить репозиторий GitHub
  - [X] Настроить переменные окружения в Vercel
  - [X] Настроить роутинг для SPA (vercel.json)
  - [X] Настроить OAuth redirect URLs в Supabase
  - [ ] Настроить кастомный домен (опционально, для финального деплоя)
  
- [ ] 7.3. Настройка Supabase для production
  - [ ] Проверить настройки безопасности (RLS политики)
  - [ ] Проверить ограничения API и rate limits
  - [ ] Настроить резервное копирование БД
  - [ ] Проверить настройки CORS
  
- [X] 7.4. Тестирование промежуточного деплоя (выполнено пользователем)
  - [X] Создание комнат - работает
  - [X] Отправка сообщений - работает
  - [X] Работа LLM - работает
  - [X] Настройки комнаты (промпт, модель) - работает
  - [X] Real-time синхронизация (в двух браузерах) - работает
  - [X] In-line редактирование системного промпта - работает
  - [ ] Тестирование на мобильных устройствах (отложено)
  - [ ] Проверка производительности (отложено до финального деплоя)
  
- [ ] 7.5. Документация и инструкции
  - [ ] Обновить README с инструкциями по деплою
  - [ ] Документировать переменные окружения
  - [ ] Создать инструкцию для пользователей (если нужно)
  - [ ] Обновить описание проекта

---

## Дополнительные задачи и заметки

### Заметки о проблемах
_Здесь будут фиксироваться проблемы, возникающие в процессе разработки_

#### ПРОБЛЕМА: RLS политика блокирует обновление настроек комнаты для пользователей, которые не являются создателями комнаты
**Описание:** При попытке обновить системный промпт или модель LLM пользователем, который не является создателем комнаты, операция блокировалась RLS политикой `"Users can update own rooms"`, которая разрешала обновление только создателю комнаты (`auth.uid() = created_by`).

**Симптомы:**
- Ошибка в консоли: "Update returned no rows - update may have been blocked by RLS"
- Модальное окно с ошибкой: "Обновление не выполнено. Проверьте права доступа к комнате."
- Логи показывают: `Can update? - false` когда текущий пользователь не является создателем

**Решение:** 
- Создана миграция `002_allow_all_users_update_rooms.sql`
- Удалена старая политика `"Users can update own rooms"`
- Создана новая политика `"Authenticated users can update rooms"`, разрешающая обновление комнат всем аутентифицированным пользователям
- **Требуется:** Применить миграцию в Supabase SQL Editor

**Статус:** ✅ Решено (миграция создана, ожидается применение)

#### ПРОБЛЕМА: OAuth редирект на localhost после деплоя на Vercel
**Описание:** После деплоя на Vercel OAuth редирект перенаправлял на localhost вместо Vercel URL, а также возникала ошибка 404 на маршруте `/auth/callback`.

**Симптомы:**
- После авторизации через Google происходил редирект на `localhost`
- Ошибка 404 на `chatrooms-phi.vercel.app/auth/callback`
- Supabase отклонял URL при добавлении в Redirect URLs

**Решение:**
- Создан файл `vercel.json` с конфигурацией rewrites для SPA роутинга
- Настроены Redirect URLs в Supabase с wildcard паттерном: `https://chatrooms-phi.vercel.app/**`
- Обновлен Site URL в Supabase на полный Vercel URL

**Статус:** ✅ Решено (OAuth работает, пользователь может войти)

#### ПРОБЛЕМА: Ограничения pgvector для больших размерностей эмбеддингов
**Описание:** При попытке использовать модель `text-embedding-3-large` с полными 3072 измерениями возникли ошибки при создании индексов, так как pgvector (IVFFlat и HNSW) поддерживает максимум 2000 измерений.

**Симптомы:**
- Ошибка при создании IVFFlat индекса: "column cannot have more than 2000 dimensions for ivfflat index"
- Ошибка при создании HNSW индекса: "column cannot have more than 2000 dimensions for hnsw index"

**Решение:**
- Использование модели `text-embedding-3-large` с параметром `dimensions=1024` через OpenAI API
- Это дает лучшее качество для русского языка, чем `text-embedding-3-small`, при этом помещается в ограничения pgvector
- Создана миграция `012_switch_to_large_embeddings.sql` для изменения схемы БД на vector(1024)
- Добавлены переменные окружения `VITE_OPENAI_EMBEDDING_MODEL` и `VITE_OPENAI_EMBEDDING_DIMENSIONS`

**Статус:** ✅ Решено (миграция применена, поиск работает корректно)

#### ПРОБЛЕМА: Несоответствие размерности эмбеддингов на production (Vercel)
**Описание:** После применения миграции на 1024 измерения и добавления переменных окружения в локальный `.env`, приложение на Vercel продолжало генерировать эмбеддинги размерностью 1536, что вызывало ошибки при сохранении в БД.

**Симптомы:**
- Ошибка: "expected 1024 dimensions, not 1536" при попытке сохранить эмбеддинги
- Все попытки пересоздания эмбеддингов заканчивались ошибками
- 0 сообщений успешно обработано при backfill

**Решение:**
- Добавлены переменные окружения в Vercel Dashboard: `VITE_OPENAI_EMBEDDING_MODEL` и `VITE_OPENAI_EMBEDDING_DIMENSIONS`
- Пересобран проект на Vercel для применения новых переменных окружения
- Добавлено логирование конфигурации эмбеддингов для диагностики
- Создана инструкция `FIX_VERCEL_EMBEDDINGS.md` для решения подобных проблем

**Статус:** ✅ Решено (переменные добавлены в Vercel, поиск работает корректно)

### Дополнительные задачи
_Здесь будут добавляться новые задачи, которые появятся в процессе разработки_

