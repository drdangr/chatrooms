# План разработки Multi-User LLM Chat MVP

## Правила заполнения плана

### Общие правила работы с планом разработки:

- **На каждом новом этапе** пишем задачу этапа и его DOD (Definition of Done) + тесткейс

- **Приступая к каждому этапу** текущие задачи помечаются в чек-боксе `[*]`, что означает, что задача в работе

- **После выполнения этапа** нужно:
  1. Пройти тесткейс самостоятельно
  2. Получить от пользователя подтверждение, что этап закрыт
  3. Только после этого можно пометить задачу в чек-боксе `[X]`, что означает, что она выполнена

- **При появлении дополнительных задач** нужно вписать их в план

- **При появлении проблем** нужно сделать в плане пометку: "**ПРОБЛЕМА:** [описание проблемы]"

- **Не удаляй из плана задачи**, если они были выполнены, а отмечай их выполненными

- **При изменении задач** попроси у пользователя подтверждения и согласуй с ним изменения, только после получения его одобрения - можно вносить изменения в план

---

## Этап 1: Инициализация проекта и настройка бэкенда ✅ ЗАВЕРШЕН

**Задача этапа:** Настроить базовую инфраструктуру проекта, создать проект в Supabase, настроить схему базы данных, настроить аутентификацию.

**DOD (Definition of Done):**
- ✅ Создан проект в Supabase
- ✅ Настроена схема БД с таблицами: users, rooms, messages, files
- ✅ Настроена аутентификация через Supabase Auth (Google OAuth)
- ✅ Создан тестовый пользователь (автоматически через триггер)
- ✅ Проверена работа подключения к БД (все тесты пройдены)

**Тесткейс:**
1. ✅ Создать проект в Supabase
2. ✅ Настроить таблицы в БД через SQL Editor или миграции
3. ✅ Проверить структуру таблиц
4. ✅ Настроить аутентификацию
5. ✅ Создать тестового пользователя (drdangr@gmail.com)
6. ✅ Проверить подключение к БД через клиент (все тесты успешны)

**Задачи:**

- [X] 1.1. Инициализировать React проект с TypeScript
  - [X] Настроить проект (Vite/Create React App)
  - [X] Установить зависимости (React, TypeScript, TailwindCSS)
  - [X] Настроить структуру папок проекта
  
- [X] 1.2. Создать и настроить проект Supabase
  - [X] Зарегистрироваться/войти в Supabase
  - [X] Создать новый проект
  - [X] Сохранить credentials (URL, anon key, service key)
  
- [X] 1.3. Создать схему базы данных
  - [X] Создать таблицу `users` (id, email, name, avatar_url, created_at)
  - [X] Создать таблицу `rooms` (id, title, system_prompt, model, created_by, created_at)
  - [X] Создать таблицу `messages` (id, room_id, sender_id, sender_name, text, timestamp, created_at)
  - [X] Создать таблицу `files` (id, room_id, uploaded_by, filename, file_url, file_type, size, created_at)
  - [X] Настроить связи между таблицами (foreign keys)
  - [X] Настроить индексы для оптимизации запросов
  - [X] Создать SQL миграцию в файле `supabase/migrations/001_initial_schema.sql`
  - [X] Применить миграцию в Supabase Dashboard
  
- [X] 1.4. Настроить аутентификацию
  - [X] Включить Supabase Auth (включен по умолчанию)
  - [X] Настроить провайдер Google OAuth
    - [X] Создать OAuth клиент в Google Cloud Console
    - [X] Получить Client ID и Client Secret
    - [X] Ввести credentials в Supabase Dashboard
    - [X] Протестировать вход через Google
  - [ ] Настроить провайдер Apple OAuth (опционально)
  - [X] Настроить политики безопасности (RLS - Row Level Security) - выполнено в миграции
  
- [X] 1.5. Установить и настроить Supabase клиент
  - [X] Установить @supabase/supabase-js
  - [X] Создать файл конфигурации с credentials
  - [X] Создать утилиту для инициализации клиента
  - [X] Создать компонент Auth для аутентификации
  - [X] Создать компонент AuthCallback для обработки OAuth callback
  - [X] Настроить роутинг (React Router)
  - [X] Создать компонент DBConnectionTest для тестирования БД
  - [X] Протестировать подключение к БД ✅ (все тесты пройдены успешно)

---

## Этап 2: Базовый UI - интерфейс комнат и сообщений

**Задача этапа:** Создать базовый пользовательский интерфейс для списка комнат и чата с сообщениями, реализовать real-time синхронизацию сообщений.

**DOD (Definition of Done):**
- Реализован компонент списка комнат (ChatList)
- Реализован компонент чата (ChatRoom) с отображением сообщений
- Реализована отправка сообщений
- Настроена real-time синхронизация через Supabase Realtime
- Пользователь может создавать комнаты, присоединяться к существующим
- Сообщения сохраняются в БД и отображаются в реальном времени

**Тесткейс:**
1. Авторизоваться в приложении
2. Создать новую комнату с названием
3. Отправить несколько сообщений
4. Открыть приложение в другом браузере/вкладке
5. Проверить, что сообщения синхронизируются в реальном времени
6. Проверить отображение истории сообщений при повторном входе

**Задачи:**

- [ ] 2.1. Создать базовую структуру компонентов
  - [ ] Создать компонент Layout/App
  - [ ] Создать компонент ChatList (список комнат)
  - [ ] Создать компонент ChatRoom (интерфейс чата)
  - [ ] Настроить роутинг (React Router)
  
- [ ] 2.2. Реализовать компонент ChatList
  - [ ] Отображение списка доступных комнат
  - [ ] Кнопка создания новой комнаты
  - [ ] Поиск комнат по названию
  - [ ] Навигация к выбранной комнате
  
- [ ] 2.3. Реализовать компонент ChatRoom
  - [ ] Отображение списка сообщений
  - [ ] Форма ввода и отправки сообщений
  - [ ] Отображение имени отправителя и времени
  - [ ] Скролл к новым сообщениям
  
- [ ] 2.4. Реализовать CRUD операции для комнат
  - [ ] Создание комнаты (INSERT в таблицу rooms)
  - [ ] Получение списка комнат (SELECT)
  - [ ] Удаление комнаты (DELETE)
  - [ ] Обновление названия комнаты (UPDATE)
  
- [ ] 2.5. Реализовать CRUD операции для сообщений
  - [ ] Отправка сообщения (INSERT в таблицу messages)
  - [ ] Получение истории сообщений комнаты (SELECT с фильтром по room_id)
  - [ ] Пагинация сообщений (загрузка по частям)
  
- [ ] 2.6. Настроить Supabase Realtime для синхронизации
  - [ ] Подписаться на изменения в таблице messages
  - [ ] Подписаться на изменения в таблице rooms
  - [ ] Обработка событий insert/update/delete
  - [ ] Обновление UI при получении новых событий
  
- [ ] 2.7. Стилизация интерфейса
  - [ ] Применить TailwindCSS для базовых стилей
  - [ ] Создать компоненты для карточек комнат
  - [ ] Создать компоненты для сообщений (пузыри чата)
  - [ ] Адаптивная верстка для мобильных устройств

---

## Этап 3: Интеграция LLM

**Задача этапа:** Интегрировать API LLM (OpenAI/Mistral) для получения ответов ассистента в чате на основе системного промпта.

**DOD (Definition of Done):**
- Настроено подключение к API OpenAI/Mistral
- Реализована функция отправки запросов к LLM
- LLM отвечает в чате на основе системного промпта комнаты
- Ответы LLM сохраняются в БД как сообщения от "LLM"
- Обработаны ошибки API и добавлены индикаторы загрузки

**Тесткейс:**
1. Создать комнату с системным промптом
2. Отправить сообщение в чат
3. Проверить, что LLM получает запрос и формирует ответ
4. Проверить сохранение ответа LLM в БД
5. Проверить отображение ответа в интерфейсе
6. Проверить обработку ошибок при недоступности API

**Задачи:**

- [ ] 3.1. Настроить API ключи и конфигурацию
  - [ ] Получить API ключ OpenAI или Mistral
  - [ ] Создать переменные окружения для хранения ключей
  - [ ] Настроить .env файл и добавить в .gitignore
  
- [ ] 3.2. Создать сервис для работы с LLM API
  - [ ] Создать функцию для отправки запросов к API
  - [ ] Реализовать форматирование системного промпта
  - [ ] Реализовать форматирование истории сообщений
  - [ ] Реализовать обработку ответа от API
  
- [ ] 3.3. Интегрировать LLM в поток сообщений
  - [ ] Настроить триггер вызова LLM при новом сообщении от пользователя
  - [ ] Передавать системный промпт комнаты в запрос
  - [ ] Передавать историю сообщений в контекст
  - [ ] Сохранять ответ LLM в БД как сообщение от "LLM"
  
- [ ] 3.4. Реализовать обработку ошибок и состояний загрузки
  - [ ] Обработка ошибок API (таймауты, rate limits, невалидные ключи)
  - [ ] Индикатор загрузки ответа LLM
  - [ ] Сообщения об ошибках для пользователя
  - [ ] Retry механизм при временных ошибках
  
- [ ] 3.5. Оптимизация запросов к LLM
  - [ ] Ограничение длины истории сообщений в контексте
  - [ ] Кэширование промптов
  - [ ] Дебаунсинг для предотвращения множественных запросов

---

## Этап 4: Настройки - промпт и выбор модели

**Задача этапа:** Реализовать интерфейс для редактирования системного промпта комнаты и выбора модели LLM.

**DOD (Definition of Done):**
- Создан компонент PromptSettings для редактирования промпта
- Реализован выбор модели LLM (gpt-4o-mini, gpt-4, mistral и т.д.)
- Изменения промпта и модели сохраняются в БД
- Изменения применяются к последующим ответам LLM
- Интерфейс интуитивно понятен и доступен

**Тесткейс:**
1. Открыть настройки комнаты
2. Изменить системный промпт на новый текст
3. Выбрать другую модель LLM
4. Сохранить изменения
5. Отправить новое сообщение
6. Проверить, что LLM использует новый промпт и модель

**Задачи:**

- [ ] 4.1. Создать компонент PromptSettings
  - [ ] Текстовое поле для редактирования системного промпта
  - [ ] Выпадающий список для выбора модели
  - [ ] Кнопки сохранения и отмены
  - [ ] Валидация введенных данных
  
- [ ] 4.2. Реализовать выбор модели LLM
  - [ ] Создать список доступных моделей
  - [ ] Отображение текущей выбранной модели
  - [ ] Обновление модели в БД при изменении
  
- [ ] 4.3. Реализовать редактирование системного промпта
  - [ ] Загрузка текущего промпта из БД
  - [ ] Редактирование в текстовом поле (поддержка многострочного ввода)
  - [ ] Сохранение промпта в БД
  - [ ] Применение промпта к последующим запросам LLM
  
- [ ] 4.4. Интегрировать настройки в интерфейс
  - [ ] Добавить кнопку/иконку настроек в ChatRoom
  - [ ] Модальное окно или отдельная страница для настроек
  - [ ] Обновление интерфейса при изменении настроек
  
- [ ] 4.5. Добавить валидацию и подсказки
  - [ ] Проверка длины промпта (максимальная длина)
  - [ ] Подсказки по использованию промптов
  - [ ] Примеры хороших промптов

---

## Этап 5: Поиск по истории чата

**Задача этапа:** Реализовать функциональность поиска по истории сообщений с фильтрацией по времени и тексту.

**DOD (Definition of Done):**
- Создан компонент SearchBar для поиска
- Реализован поиск по тексту сообщений
- Реализована фильтрация по временному диапазону
- Результаты поиска отображаются с подсветкой найденного текста
- Пользователь может перейти к найденному сообщению в чате

**Тесткейс:**
1. Открыть комнату с историей сообщений
2. Ввести текст в поисковую строку
3. Проверить отображение найденных сообщений
4. Применить фильтр по дате
5. Проверить корректность результатов
6. Кликнуть на результат и проверить переход к сообщению

**Задачи:**

- [ ] 5.1. Создать компонент SearchBar
  - [ ] Поле ввода для поискового запроса
  - [ ] Кнопка поиска
  - [ ] Фильтр по дате/времени (date picker)
  - [ ] Отображение результатов поиска
  
- [ ] 5.2. Реализовать поиск по тексту
  - [ ] SQL запрос с LIKE или полнотекстовым поиском
  - [ ] Поиск по полю text в таблице messages
  - [ ] Подсветка найденного текста в результатах
  - [ ] Регистронезависимый поиск
  
- [ ] 5.3. Реализовать фильтрацию по времени
  - [ ] Выбор диапазона дат (от - до)
  - [ ] Фильтрация по timestamp в SQL запросе
  - [ ] Комбинирование фильтра по тексту и времени
  
- [ ] 5.4. Реализовать отображение результатов
  - [ ] Список найденных сообщений с контекстом
  - [ ] Подсветка совпадений
  - [ ] Информация об авторе и времени
  - [ ] Пагинация результатов
  
- [ ] 5.5. Интегрировать поиск в интерфейс
  - [ ] Добавить SearchBar в ChatRoom или отдельную секцию
  - [ ] Переход к найденному сообщению в чате
  - [ ] Скролл к выделенному сообщению
  - [ ] Подсветка найденного сообщения в истории

---

## Этап 6: Загрузка и просмотр файлов

**Задача этапа:** Реализовать функциональность загрузки файлов в комнаты и их просмотр, используя Supabase Storage.

**DOD (Definition of Done):**
- Настроен Supabase Storage bucket для файлов
- Реализована загрузка файлов через интерфейс
- Файлы сохраняются в Storage и метаданные в БД
- Реализован просмотр списка файлов комнаты
- Реализован просмотр/скачивание файлов
- Файлы привязаны к комнатам и доступны участникам

**Тесткейс:**
1. Открыть комнату
2. Загрузить файл (текстовый, изображение, PDF)
3. Проверить сохранение файла в Storage
4. Проверить отображение файла в списке файлов комнаты
5. Открыть/скачать файл
6. Проверить доступность файла для других участников комнаты

**Задачи:**

- [ ] 6.1. Настроить Supabase Storage
  - [ ] Создать bucket для хранения файлов
  - [ ] Настроить политики доступа (RLS для Storage)
  - [ ] Ограничения на размер и типы файлов
  
- [ ] 6.2. Создать компонент FilePanel
  - [ ] Список загруженных файлов комнаты
  - [ ] Кнопка/зона для загрузки файлов
  - [ ] Отображение метаданных файлов (имя, размер, тип, дата)
  - [ ] Иконки по типам файлов
  
- [ ] 6.3. Реализовать загрузку файлов
  - [ ] Drag & drop или выбор файла через input
  - [ ] Валидация типа и размера файла
  - [ ] Загрузка файла в Supabase Storage
  - [ ] Сохранение метаданных в таблицу files
  - [ ] Индикатор прогресса загрузки
  
- [ ] 6.4. Реализовать просмотр файлов
  - [ ] Получение списка файлов комнаты из БД
  - [ ] Генерация URL для доступа к файлам
  - [ ] Просмотр изображений в интерфейсе
  - [ ] Скачивание файлов
  - [ ] Открытие файлов в новой вкладке
  
- [ ] 6.5. Интегрировать файлы в чат
  - [ ] Отображение файлов в сообщениях (если прикреплены)
  - [ ] Возможность прикрепить файл к сообщению
  - [ ] Превью файлов в сообщениях
  
- [ ] 6.6. Реализовать удаление файлов
  - [ ] Кнопка удаления для владельца файла
  - [ ] Удаление файла из Storage
  - [ ] Удаление записи из БД

---

## Этап 7: Деплой и финализация MVP

**Задача этапа:** Развернуть приложение на Vercel, настроить переменные окружения, провести финальное тестирование и подготовить MVP к использованию.

**DOD (Definition of Done):**
- Приложение развернуто на Vercel
- Настроены все переменные окружения
- Протестированы все основные функции
- Приложение доступно по публичному URL
- Документация по деплою обновлена
- MVP готов к использованию

**Тесткейс:**
1. Развернуть приложение на Vercel
2. Настроить переменные окружения
3. Проверить работу аутентификации
4. Проверить работу всех функций (чат, LLM, настройки, поиск, файлы)
5. Протестировать на разных устройствах/браузерах
6. Проверить производительность и скорость загрузки

**Задачи:**

- [ ] 7.1. Подготовка к деплою
  - [ ] Убедиться, что код готов к production
  - [ ] Проверить отсутствие console.log и debug кода
  - [ ] Оптимизировать сборку (минификация, tree-shaking)
  - [ ] Проверить работу в production режиме локально
  
- [ ] 7.2. Настройка Vercel
  - [ ] Создать проект в Vercel
  - [ ] Подключить репозиторий GitHub
  - [ ] Настроить переменные окружения в Vercel
  - [ ] Настроить домен (опционально)
  
- [ ] 7.3. Настройка Supabase для production
  - [ ] Проверить настройки безопасности (RLS политики)
  - [ ] Проверить ограничения API и rate limits
  - [ ] Настроить резервное копирование БД
  - [ ] Проверить настройки CORS
  
- [ ] 7.4. Финальное тестирование
  - [ ] E2E тестирование всех функций
  - [ ] Тестирование на разных браузерах
  - [ ] Тестирование на мобильных устройствах
  - [ ] Проверка производительности
  - [ ] Проверка безопасности
  
- [ ] 7.5. Документация и инструкции
  - [ ] Обновить README с инструкциями по деплою
  - [ ] Документировать переменные окружения
  - [ ] Создать инструкцию для пользователей (если нужно)
  - [ ] Обновить описание проекта

---

## Дополнительные задачи и заметки

### Заметки о проблемах
_Здесь будут фиксироваться проблемы, возникающие в процессе разработки_

### Дополнительные задачи
_Здесь будут добавляться новые задачи, которые появятся в процессе разработки_

